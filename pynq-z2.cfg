if { [info exists CHIPNAME] } {
    global _CHIPNAME
    set _CHIPNAME $CHIPNAME
} else {
    global _CHIPNAME
    set _CHIPNAME zynq
}

if { [info exists SMP] } {
    global _SMP
    set _SMP 1
} else {
    global _SMP
    set _SMP 0
}

interface ftdi
ftdi_vid_pid 0x0403 0x6010
ftdi_channel 0
ftdi_layout_init 0x00e8 0x60eb
ftdi_layout_signal nSRST -data 0x0010

transport select jtag
reset_config srst_only srst_push_pull
source [find target/zynq_7000.cfg]

proc zynq_reset_ocm {target} {
    # Unlock SLCR
    $target mww 0xf8000008 0xdf0d
    # move ocm back low
    $target mww 0xf8000910 0x18
    # Lock SLCR
    $target mww 0xf8000004 0x767b

    targets $target
    reg cpsr 0x60000113

}
proc zynq_reset {} {
    zynq_reset_ocm zynq.cpu1
    reg pc 0xffffff34
    zynq_reset_ocm zynq.cpu0
    reg pc 0x0
}

proc load_boot {} {
    load_image generated/software/apps/boot/boot.elf 0x000 elf
}

proc zynqpl_reset_release {target} {
    # Unlock SLCR
    $target mww 0xf8000008 0xdf0d
    # Enable level shifters, both PL-PS and PS-PL
    $target mww 0xf8000900 0xF
    # Release FPGA reset
    $target mww 0xf8000240 0x0
    # Lock SLCR
    $target mww 0xf8000004 0x767b
}


#
# Hack to get the registers into a stable state when first booting a zynq in
# JTAG mode. If r11 is pointing to an invalid address and you use gdb to set a
# register the write will fail because gdb attempts to scan or unwind the
# current frame and the bad address seems to lock the bus up. This code puts
# the registers into the OCM and hopefull safe.
#
proc zynq_clear_registers { target } {
    echo "Zynq-7000 Series setup: $target"
    set _OCM_END 0x0003FFF0
    $target mww phys 0xF8007000 0x4E00E07F
    $target reg r0 0
    $target reg r1 0
    $target reg r2 0
    $target reg r3 0
    $target reg r4 0
    $target reg r5 0
    $target reg r6 0
    $target reg r7 0
    $target reg r8 0
    $target reg r9 0
    $target reg r10 0
    $target reg r11 $_OCM_END
    $target reg sp_svc $_OCM_END
    $target reg lr_svc $_OCM_END
    $target reg sp_abt $_OCM_END
    $target reg lr_abt $_OCM_END
    $target reg sp_und $_OCM_END
    $target reg lr_und $_OCM_END
}

proc zynq_disable_mmu_and_caches { target } {
    # arm mcr pX op1 CRn CRm op2 value
    echo "Disable MMU and caches"
    # Invalidate caches
    catch {
        $target arm mcr 15 0 7 5 0 0
        $target arm mcr 15 0 7 7 0 0
        # Invalidate all TLBs
        $target arm mcr 15 0 8 5 0 0
        $target arm mcr 15 0 8 6 0 0
        $target arm mcr 15 0 8 7 0 0
        $target arm mcr 15 4 8 3 0 0
        $target arm mcr 15 4 8 7 0 0
        set cp [$target arm mrc 15 0 1 0 0]
        echo "SCTRL => [format 0x%x $cp]"
        set mask [expr 1 << 29 | 1 << 12 | 1 << 11 | 1 << 2 | 1 << 1 | 1 << 0]
        set cp [expr ($cp & ~$mask)]
        $target arm mcr 15 0 1 0 0 $cp
        echo "SCTRL <= [format 0x%x $cp]"
    }
}

proc zynq_boot_ocm_setup { } {
    #
    # Enable the OCM
    #
    echo "Zynq Boot OCM setup"
    catch {
      mww phys 0xF8000008 0xDF0D
      mww phys 0xF8000238 0
      mww phys 0xF8000910 0xC
    }
}



# Load the FSBL into OCM and run it.
init
halt
#targets zynq.cpu0 zynq.cpu1
#load_image generated/software/apps/boot/boot.elf 0x000 elf
#load  ../workspace/pynq-z2/export/pynq-z2/sw/pynq-z2/boot/fsbl.elf 0x000 elf
#resume 0
#sleep 2000
#halt
#adapter_khz 20000
# FPGA fabric sequence.
#zynqpl_program zynq_pl.bs
#pld load 0 fsbl/microzed_usrp_platform/microzed_top.bit
#sleep 100
#zynqpl_reset_release zynq.cpu0

targets zynq.cpu0
adapter_khz 20000
